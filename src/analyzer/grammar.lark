// grammar.lark - Gramática Lark para el proyecto (compatible con los tests entregados)

%ignore /[ \t\f\r]+/            // espacios en blanco
%ignore /\n+/                   // saltos de línea (se manejan por tokens)
%ignore COMMENT

// ----- Terminals -----
LPAR: "("
RPAR: ")"
LSQB: "["
RSQB: "]"
COMMA: ","
SEMI: ";"
COLON: ":"
ASSIGN: ":="
PLUS: "+"
MINUS: "-"
MUL: "*"
DIV: "/"
EQ: "="
LT: "<"
GT: ">"
LE: "<="
GE: ">="

ARROW: "<-"

PROCEDURE: "PROCEDURE"
BEGINKW: "BEGIN"
ENDKW: "END"
IFKW: "IF"
THENKW: "THEN"
ELSEKW: "ELSE"
FORKW: "FOR"
TOWK: "TO"
DOKW: "DO"
WHILEKW: "WHILE"
REPEATKW: "REPEAT"
UNTILKW: "UNTIL"
RETURNKW: "RETURN"
CALLKW: "CALL"

COMMENT: "►" /[^\n]*/                // comentario con el símbolo ►
%ignore /\/\/[^\n]*/                 // también C++ style comments

// IDENTIFIERS and NUMBERS
%import common.CNAME -> IDENTIFIER
%import common.INT -> NUMBER

// ----- Start -----
start: program

program: (routine)*

routine: PROCEDURE IDENTIFIER "(" param_list? ")" block

param_list: param (COMMA param)*
param: IDENTIFIER

block: BEGINKW stmt_list ENDKW

stmt_list: (statement)*

statement: simple_stmt
         | compound_stmt

// ----- Simple statements (terminated by ;) -----
simple_stmt: assign_stmt SEMI
           | return_stmt SEMI
           | call_stmt SEMI
           | SEMI

assign_stmt: lvalue ASSIGN expr
lvalue: IDENTIFIER (indexing)*
      | field_access

field_access: IDENTIFIER "." IDENTIFIER

call_stmt: CALLKW IDENTIFIER "(" arg_list? ")"

arg_list: expr (COMMA expr)*

return_stmt: RETURNKW expr

// ----- Compound / control statements -----
compound_stmt: if_stmt
             | for_stmt
             | while_stmt
             | repeat_stmt
             | block

if_stmt: IFKW expr THENKW stmt_list (ELSEKW stmt_list)? ENDKW

for_stmt: FORKW IDENTIFIER ASSIGN expr TOWK expr DOKW stmt_list ENDKW

while_stmt: WHILEKW expr DOKW stmt_list ENDKW

repeat_stmt: REPEATKW stmt_list UNTILKW expr SEMI?

// ----- Expressions -----
?expr: expr_or

?expr_or: expr_or "or" expr_and  -> or_expr
        | expr_and

?expr_and: expr_and "and" expr_cmp -> and_expr
         | expr_cmp

?expr_cmp: arith_expr ((">" | "<" | ">=" | "<=" | "=") arith_expr)?
arith_expr: arith_expr ("+" | "-") term   -> binop
          | term

term: term ("*" | "/") factor              -> binop
    | factor

?factor: NUMBER
       | IDENTIFIER function_call
       | IDENTIFIER indexing                  -> array_access
       | IDENTIFIER                            -> var
       | "(" expr ")"

function_call: "(" arg_list? ")"
indexing: ("[" expr "]")+

// ----- Helpers for tokenizer friendliness -----
%ignore /[ \t\f\r]+/    // spaces
